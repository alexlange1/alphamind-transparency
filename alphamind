#!/usr/bin/env python3
"""
Alphamind CLI - TAO20 Subnet Management Tool
Inspired by successful Bittensor subnet patterns
"""
import os
import sys
import json
import click
import asyncio
from pathlib import Path
from typing import Optional

# Add the project root to Python path
PROJECT_ROOT = Path(__file__).parent
sys.path.insert(0, str(PROJECT_ROOT))

from subnet.common.settings import get_settings
from subnet.miner.loop import run_once as miner_run_once
from subnet.validator.service import aggregate_and_emit
from subnet.sim.vault import VaultState, mint_tao_extended, redeem_in_kind_extended


@click.group()
@click.version_option(version="1.0.0")
def cli():
    """Alphamind CLI - TAO20 Subnet Management Tool"""
    pass


@cli.group()
def miner():
    """Miner operations and management"""
    pass


@cli.group() 
def validator():
    """Validator operations and management"""
    pass


@cli.group()
def vault():
    """Vault simulation and operations"""
    pass


@cli.group()
def deploy():
    """Deployment and infrastructure management"""
    pass


# ========== MINER COMMANDS ==========

@miner.command("emit-once")
@click.option("--type", "report_type", type=click.Choice(["emissions", "prices", "both"]), default="both")
@click.option("--out-dir", type=click.Path(), help="Output directory for reports")
@click.option("--miner-id", default="cli-miner", help="Miner identifier")
@click.option("--secret", help="HMAC secret (if not using hotkey)")
def emit_once(report_type: str, out_dir: Optional[str], miner_id: str, secret: Optional[str]):
    """Emit one-shot reports (emissions, prices, or both)"""
    settings = get_settings()
    output_dir = Path(out_dir) if out_dir else Path(settings.out_dir)
    
    click.echo(f"ğŸš€ Emitting {report_type} reports...")
    click.echo(f"ğŸ“ Output directory: {output_dir}")
    click.echo(f"ğŸ‘¤ Miner ID: {miner_id}")
    
    try:
        if report_type in ["emissions", "both"]:
            click.echo("ğŸ“Š Emitting emissions report...")
            # Use existing miner logic
            os.system(f"python {PROJECT_ROOT}/subnet/miner/loop.py --emit-emissions-once")
            
        if report_type in ["prices", "both"]:
            click.echo("ğŸ’° Emitting price report...")
            os.system(f"python {PROJECT_ROOT}/subnet/miner/loop.py --emit-prices-once")
            
        click.echo("âœ… Reports emitted successfully!")
        
    except Exception as e:
        click.echo(f"âŒ Error emitting reports: {e}", err=True)
        sys.exit(1)


@miner.command("run")
@click.option("--interval", default=300, help="Report interval in seconds")
@click.option("--out-dir", type=click.Path(), help="Output directory for reports")
@click.option("--daemon", is_flag=True, help="Run as daemon")
def run_miner(interval: int, out_dir: Optional[str], daemon: bool):
    """Run miner in continuous mode"""
    settings = get_settings()
    output_dir = Path(out_dir) if out_dir else Path(settings.out_dir)
    
    click.echo(f"ğŸš€ Starting miner...")
    click.echo(f"â±ï¸  Interval: {interval}s")
    click.echo(f"ğŸ“ Output: {output_dir}")
    click.echo(f"ğŸ”„ Daemon mode: {daemon}")
    
    if daemon:
        click.echo("âš ï¸  Daemon mode not yet implemented. Running in foreground...")
    
    # Implement continuous miner loop
    click.echo("ğŸ’¡ Use Ctrl+C to stop")
    try:
        while True:
            emit_once.callback("both", str(output_dir), "daemon-miner", None)
            import time
            time.sleep(interval)
    except KeyboardInterrupt:
        click.echo("\nğŸ›‘ Miner stopped by user")


# ========== VALIDATOR COMMANDS ==========

@validator.command("aggregate")
@click.option("--in-dir", type=click.Path(exists=True), help="Input directory with reports")
@click.option("--out-file", type=click.Path(), help="Output file for aggregated weights")
@click.option("--top-n", default=20, help="Number of top subnets to include")
def aggregate_reports(in_dir: Optional[str], out_file: Optional[str], top_n: int):
    """Aggregate miner reports into index weights"""
    settings = get_settings()
    input_dir = Path(in_dir) if in_dir else Path(settings.in_dir)
    output_file = Path(out_file) if out_file else input_dir / "weightset_latest.json"
    
    click.echo(f"ğŸ“Š Aggregating reports...")
    click.echo(f"ğŸ“‚ Input: {input_dir}")
    click.echo(f"ğŸ“„ Output: {output_file}")
    click.echo(f"ğŸ† Top N: {top_n}")
    
    try:
        aggregate_and_emit(input_dir, output_file, top_n)
        click.echo("âœ… Aggregation completed successfully!")
        
        # Show summary
        if output_file.exists():
            with open(output_file) as f:
                data = json.load(f)
                weights = data.get("weights", {})
                click.echo(f"ğŸ“ˆ Generated weights for {len(weights)} subnets")
                
    except Exception as e:
        click.echo(f"âŒ Error during aggregation: {e}", err=True)
        sys.exit(1)


@validator.command("serve")
@click.option("--host", default="127.0.0.1", help="Host to bind to")
@click.option("--port", default=8000, help="Port to bind to")
@click.option("--reload", is_flag=True, help="Enable auto-reload for development")
def serve_api(host: str, port: int, reload: bool):
    """Start the validator API server"""
    click.echo(f"ğŸš€ Starting Alphamind API server...")
    click.echo(f"ğŸŒ URL: http://{host}:{port}")
    click.echo(f"ğŸ“Š Dashboard: http://{host}:{port}/dashboard")
    click.echo(f"ğŸ”„ Reload: {reload}")
    
    # Use uvicorn to start the server
    import uvicorn
    uvicorn.run(
        "subnet.validator.api:app",
        host=host,
        port=port,
        reload=reload,
        log_level="info"
    )


# ========== VAULT COMMANDS ==========

@vault.command("mint")
@click.option("--amount", type=float, required=True, help="Amount of TAO to mint with")
@click.option("--state-file", type=click.Path(), help="Vault state file")
@click.option("--weights-file", type=click.Path(), help="Current index weights file")
@click.option("--prices-file", type=click.Path(), help="Current prices file")
def simulate_mint(amount: float, state_file: Optional[str], weights_file: Optional[str], prices_file: Optional[str]):
    """Simulate TAO20 minting operation"""
    settings = get_settings()
    base_dir = Path(settings.out_dir)
    
    # Load files
    state_path = Path(state_file) if state_file else base_dir / "vault_state.json"
    weights_path = Path(weights_file) if weights_file else base_dir / "weights.json"
    prices_path = Path(prices_file) if prices_file else base_dir / "prices.json"
    
    click.echo(f"ğŸ¦ Simulating mint operation...")
    click.echo(f"ğŸ’° Amount: {amount} TAO")
    
    try:
        # Load current state, weights, and prices
        if state_path.exists():
            with open(state_path) as f:
                state_data = json.load(f)
                state = VaultState.from_json(json.dumps(state_data))
        else:
            state = VaultState(holdings={}, tao20_supply=0.0, last_nav_tao=0.0)
            
        if weights_path.exists():
            with open(weights_path) as f:
                weights = json.load(f).get("weights", {})
                weights = {int(k): float(v) for k, v in weights.items()}
        else:
            click.echo("âš ï¸  No weights file found, using demo weights")
            weights = {1: 0.3, 2: 0.25, 3: 0.2, 4: 0.15, 5: 0.1}
            
        if prices_path.exists():
            with open(prices_path) as f:
                prices = json.load(f).get("prices", {})
                prices = {int(k): float(v) for k, v in prices.items()}
        else:
            click.echo("âš ï¸  No prices file found, using demo prices")
            prices = {1: 100.0, 2: 150.0, 3: 80.0, 4: 120.0, 5: 90.0}
        
        # Simulate mint
        result_state, mint_result = mint_tao_extended(amount, weights, prices, state)
        
        # Display results
        click.echo("âœ… Mint simulation completed!")
        click.echo(f"ğŸª™ TAO20 minted: {mint_result.minted:.6f}")
        click.echo(f"ğŸ“Š NAV per TAO20: {mint_result.nav_per_tao20:.6f}")
        click.echo(f"ğŸ“ˆ New total supply: {result_state.tao20_supply:.6f}")
        
        # Save updated state
        with open(state_path, "w") as f:
            json.dump(json.loads(result_state.to_json()), f, indent=2)
        click.echo(f"ğŸ’¾ Updated state saved to {state_path}")
        
    except Exception as e:
        click.echo(f"âŒ Error simulating mint: {e}", err=True)
        sys.exit(1)


@vault.command("status")
@click.option("--state-file", type=click.Path(), help="Vault state file")
def vault_status(state_file: Optional[str]):
    """Show current vault status"""
    settings = get_settings()
    state_path = Path(state_file) if state_file else Path(settings.out_dir) / "vault_state.json"
    
    click.echo("ğŸ¦ Vault Status")
    click.echo("=" * 50)
    
    try:
        if not state_path.exists():
            click.echo("âš ï¸  No vault state file found. Run 'alphamind vault mint' first.")
            return
            
        with open(state_path) as f:
            state_data = json.load(f)
            
        click.echo(f"ğŸ“Š TAO20 Supply: {state_data.get('tao20_supply', 0):.6f}")
        click.echo(f"ğŸ’° Last NAV: {state_data.get('last_nav_tao', 0):.6f} TAO")
        click.echo(f"ğŸ’³ TX Fees: {state_data.get('fees_tx_tao', 0):.6f} TAO")
        click.echo(f"ğŸ›ï¸  Mgmt Fees: {state_data.get('fees_mgmt_tao', 0):.6f} TAO")
        
        holdings = state_data.get('holdings', {})
        if holdings:
            click.echo("\nğŸ¦ Holdings:")
            for netuid, amount in holdings.items():
                click.echo(f"  Subnet {netuid}: {amount:.6f}")
                
    except Exception as e:
        click.echo(f"âŒ Error reading vault status: {e}", err=True)


# ========== DEPLOYMENT COMMANDS ==========

@deploy.command("init")
@click.option("--network", type=click.Choice(["testnet", "mainnet"]), default="testnet")
@click.option("--out-dir", type=click.Path(), help="Output directory")
def init_deployment(network: str, out_dir: Optional[str]):
    """Initialize deployment configuration"""
    settings = get_settings()
    output_dir = Path(out_dir) if out_dir else Path(settings.out_dir)
    
    click.echo(f"ğŸš€ Initializing Alphamind deployment...")
    click.echo(f"ğŸŒ Network: {network}")
    click.echo(f"ğŸ“ Output: {output_dir}")
    
    # Create directory structure
    output_dir.mkdir(parents=True, exist_ok=True)
    (output_dir / "state").mkdir(exist_ok=True)
    
    # Create initial config
    config = {
        "network": network,
        "initialized_at": "2025-01-01T00:00:00Z",
        "settings": {
            "emissions_quorum": 0.33,
            "price_quorum": 0.33,
            "top_n_subnets": 20,
            "tx_fee_bps": 20,
            "mgmt_fee_bps": 100
        }
    }
    
    config_path = output_dir / "alphamind_config.json"
    with open(config_path, "w") as f:
        json.dump(config, f, indent=2)
        
    click.echo("âœ… Deployment initialized successfully!")
    click.echo(f"ğŸ“„ Config: {config_path}")
    click.echo("\nğŸ“‹ Next steps:")
    click.echo("  1. alphamind miner emit-once --type both")
    click.echo("  2. alphamind validator aggregate")
    click.echo("  3. alphamind validator serve")


@deploy.command("health")
def health_check():
    """Check system health and status"""
    click.echo("ğŸ¥ Alphamind Health Check")
    click.echo("=" * 50)
    
    settings = get_settings()
    
    # Check directories
    out_dir = Path(settings.out_dir)
    click.echo(f"ğŸ“ Output directory: {out_dir}")
    click.echo(f"   Exists: {'âœ…' if out_dir.exists() else 'âŒ'}")
    
    # Check for required files
    required_files = [
        "weightset_latest.json",
        "vault_state.json", 
        "prices.json"
    ]
    
    click.echo("\nğŸ“„ Required files:")
    for file_name in required_files:
        file_path = out_dir / file_name
        exists = file_path.exists()
        click.echo(f"   {file_name}: {'âœ…' if exists else 'âŒ'}")
    
    # Check API connectivity
    try:
        import requests
        response = requests.get("http://127.0.0.1:8000/healthz", timeout=5)
        api_status = "âœ…" if response.status_code == 200 else f"âŒ ({response.status_code})"
    except:
        api_status = "âŒ (not reachable)"
    
    click.echo(f"\nğŸŒ API Health: {api_status}")
    
    # Overall status
    click.echo(f"\nğŸ¯ Overall Status: {'âœ… Healthy' if out_dir.exists() else 'âš ï¸  Needs Setup'}")


# ========== UTILITY COMMANDS ==========

@cli.command("demo")
@click.option("--scenario", type=click.Choice(["full", "mint", "aggregate"]), default="full")
def run_demo(scenario: str):
    """Run demonstration scenarios"""
    click.echo(f"ğŸ­ Running {scenario} demo...")
    
    if scenario in ["full", "aggregate"]:
        click.echo("ğŸ“Š Step 1: Emitting demo reports...")
        emit_once.callback("both", None, "demo-miner", None)
        
        click.echo("ğŸ“Š Step 2: Aggregating reports...")
        aggregate_reports.callback(None, None, 20)
    
    if scenario in ["full", "mint"]:
        click.echo("ğŸ¦ Step 3: Simulating vault operations...")
        simulate_mint.callback(100.0, None, None, None)
        vault_status.callback(None)
    
    if scenario == "full":
        click.echo("ğŸŒ Step 4: Starting API server...")
        click.echo("Run 'alphamind validator serve' to start the API")
    
    click.echo("âœ… Demo completed!")


@cli.command("version")
def version():
    """Show version information"""
    click.echo("Alphamind TAO20 Subnet v1.0.0")
    click.echo("Built with â¤ï¸  for the Bittensor ecosystem")


if __name__ == "__main__":
    cli()
