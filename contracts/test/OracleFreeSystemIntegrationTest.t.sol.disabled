// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

import "forge-std/Test.sol";
import "../src/TAO20CoreV2OracleFree.sol";
import "../src/OracleFreeNAVCalculator.sol";
import "../src/StakingManager.sol";
import "../src/TAO20V2.sol";

/**
 * @title OracleFreeSystemIntegrationTest
 * @dev End-to-end integration tests for the complete oracle-free TAO20 system
 */
contract OracleFreeSystemIntegrationTest is Test {
    // All system contracts
    TAO20CoreV2OracleFree public tao20Core;
    OracleFreeNAVCalculator public navCalculator;
    StakingManager public stakingManager;
    TAO20V2 public tao20Token;
    
    // Test participants
    address public deployer = address(0x1);
    address public alice = address(0x2);
    address public bob = address(0x3);
    address public charlie = address(0x4);
    address public miner1 = address(0x10);
    address public miner2 = address(0x11);
    address public miner3 = address(0x12);
    
    // System events
    event SystemDeployed(address core, address navCalculator, address stakingManager, address token);
    event Phase2Activated(uint256 timestamp);
    event EpochAdvanced(uint256 newEpoch, uint256 timestamp);
    
    function setUp() public {
        vm.startPrank(deployer);
        
        // Deploy the complete oracle-free system
        _deployOracleFreeSystem();
        
        vm.stopPrank();
        
        // Setup test accounts
        _setupTestAccounts();
    }
    
    function _deployOracleFreeSystem() internal {
        // 1. Deploy StakingManager (foundation)
        stakingManager = new StakingManager();
        
        // 2. Deploy NAVCalculator (depends on StakingManager)
        navCalculator = new OracleFreeNAVCalculator(address(stakingManager));
        
        // 3. Deploy core contract (orchestrates everything and creates token)
        tao20Core = new TAO20CoreV2OracleFree(
            address(stakingManager),
            address(navCalculator),
            "TAO20 Oracle-Free Index",
            "TAO20"
        );
        
        // 4. Get the token created by the core contract
        tao20Token = TAO20V2(address(tao20Core.tao20Token()));
        
        emit SystemDeployed(
            address(tao20Core),
            address(navCalculator),
            address(stakingManager),
            address(tao20Token)
        );
    }
    
    function _setupTestAccounts() internal {
        address[] memory accounts = new address[](6);
        accounts[0] = alice;
        accounts[1] = bob;
        accounts[2] = charlie;
        accounts[3] = miner1;
        accounts[4] = miner2;
        accounts[5] = miner3;
        
        for (uint i = 0; i < accounts.length; i++) {
            vm.deal(accounts[i], 1000 ether);
        }
    }
    
    // ===================== SYSTEM DEPLOYMENT TESTS =====================
    
    function test_SystemDeploymentAndConfiguration() public {
        // Verify all contracts are deployed and configured correctly
        assertTrue(address(tao20Core) != address(0), "Core contract should be deployed");
        assertTrue(address(navCalculator) != address(0), "NAV calculator should be deployed");
        assertTrue(address(stakingManager) != address(0), "Staking manager should be deployed");
        assertTrue(address(tao20Token) != address(0), "TAO20 token should be deployed");
        
        // Verify contract integrations
        assertEq(address(tao20Core.stakingManager()), address(stakingManager));
        assertEq(address(tao20Core.navCalculator()), address(navCalculator));
        assertEq(address(tao20Core.tao20Token()), address(tao20Token));
        
        // Verify permissions
        assertEq(tao20Token.authorizedMinter(), address(tao20Core));
        
        // Verify initial state
        assertEq(tao20Core.getCurrentNAV(), 1e18, "Initial NAV should be 1.0");
        assertEq(tao20Token.totalSupply(), 0, "Initial supply should be 0");
        
        (bool phase2Active,,,) = navCalculator.getPhaseInfo();
        assertFalse(phase2Active, "Should start in Phase 1");
    }
    
    // ===================== PHASE 1 OPERATION TESTS =====================
    
    function test_Phase1BasicOperations() public {
        // In Phase 1, NAV should always be 1.0
        assertEq(tao20Core.getCurrentNAV(), 1e18, "Phase 1 NAV should be 1.0");
        assertEq(navCalculator.getCurrentNAV(), 1e18, "NAV calculator should return 1.0");
        
        // NAV updates should not change value in Phase 1
        uint256 navBefore = tao20Core.getCurrentNAV();
        tao20Core.updateNAV();
        uint256 navAfter = tao20Core.getCurrentNAV();
        
        assertEq(navBefore, navAfter, "NAV should not change in Phase 1");
        
        // Multiple updates should still return 1.0
        for (uint i = 0; i < 5; i++) {
            vm.warp(block.timestamp + 3600); // Advance 1 hour
            uint256 nav = tao20Core.updateNAV();
            assertEq(nav, 1e18, "NAV should remain 1.0 in Phase 1");
        }
    }
    
    function test_Phase1MinerTracking() public {
        // Verify miners can be tracked even in Phase 1
        TAO20CoreV2OracleFree.MinerStats memory stats1 = tao20Core.getMinerStats(miner1);
        TAO20CoreV2OracleFree.MinerStats memory stats2 = tao20Core.getMinerStats(miner2);
        
        assertEq(stats1.totalVolume, 0, "Miner1 should have zero volume initially");
        assertEq(stats2.totalVolume, 0, "Miner2 should have zero volume initially");
        
        // System should track zero active miners initially
        address[] memory activeMiners = tao20Core.getActiveMiners();
        assertEq(activeMiners.length, 0, "Should have no active miners initially");
    }
    
    // ===================== PHASE TRANSITION TESTS =====================
    
    function test_Phase1ToPhase2Transition() public {
        // Verify starting in Phase 1
        (bool phase2Active,,,) = navCalculator.getPhaseInfo();
        assertFalse(phase2Active, "Should start in Phase 1");
        assertEq(tao20Core.getCurrentNAV(), 1e18, "Phase 1 NAV should be 1.0");
        
        // Only staking manager can activate Phase 2
        vm.expectRevert();
        navCalculator.activateEmissionWeighting();
        
        // Activate Phase 2 properly
        vm.prank(address(stakingManager));
        navCalculator.activateEmissionWeighting();
        
        emit Phase2Activated(block.timestamp);
        
        // Verify Phase 2 is active
        (phase2Active,,,) = navCalculator.getPhaseInfo();
        assertTrue(phase2Active, "Should be in Phase 2");
        
        // NAV can now change in Phase 2
        vm.warp(block.timestamp + 3600);
        uint256 newNAV = tao20Core.updateNAV();
        assertGt(newNAV, 0, "Phase 2 NAV should be positive");
    }
    
    function test_Phase2ToPhase1Transition() public {
        // First activate Phase 2
        vm.prank(address(stakingManager));
        navCalculator.activateEmissionWeighting();
        
        // Update NAV in Phase 2
        vm.warp(block.timestamp + 3600);
        uint256 phase2NAV = tao20Core.updateNAV();
        
        // Deactivate back to Phase 1
        vm.prank(address(stakingManager));
        navCalculator.deactivateEmissionWeighting();
        
        // Verify back in Phase 1
        (bool phase2Active,,) = navCalculator.getPhaseInfo();
        assertFalse(phase2Active, "Should be back in Phase 1");
        assertEq(tao20Core.getCurrentNAV(), 1e18, "Should be back to 1.0 NAV");
    }
    
    // ===================== EPOCH MANAGEMENT TESTS =====================
    
    function test_EpochManagement() public {
        // Check initial epoch
        (uint256 currentEpoch, uint256 epochStartTime,,,) = tao20Core.getEpochInfo();
        assertEq(currentEpoch, 1, "Should start at epoch 1");
        assertGt(epochStartTime, 0, "Epoch start time should be set");
        
        // Cannot advance epoch too early
        vm.expectRevert();
        tao20Core.advanceEpoch();
        
        // Advance time and epoch
        vm.warp(block.timestamp + 24 * 3600 + 1); // More than 24 hours
        
        tao20Core.advanceEpoch();
        emit EpochAdvanced(2, block.timestamp);
        
        (uint256 newEpoch,,,, ) = tao20Core.getEpochInfo();
        assertEq(newEpoch, 2, "Should be in epoch 2");
        
        // Advance multiple epochs
        for (uint i = 0; i < 3; i++) {
            vm.warp(block.timestamp + 24 * 3600 + 1);
            tao20Core.advanceEpoch();
        }
        
        (uint256 finalEpoch,,,, ) = tao20Core.getEpochInfo();
        assertEq(finalEpoch, 5, "Should be in epoch 5 after multiple advances");
    }
    
    // ===================== MULTI-MINER SYSTEM TESTS =====================
    
    function test_MultiMinerTracking() public {
        // Initialize tracking for multiple miners
        address[] memory miners = new address[](3);
        miners[0] = miner1;
        miners[1] = miner2;
        miners[2] = miner3;
        
        // Verify all miners start with zero stats
        for (uint i = 0; i < miners.length; i++) {
            TAO20CoreV2OracleFree.MinerStats memory stats = tao20Core.getMinerStats(miners[i]);
            assertEq(stats.totalVolume, 0, "Miner should start with zero volume");
            assertEq(stats.transactionCount, 0, "Miner should start with zero transactions");
            assertEq(stats.lastActivity, 0, "Miner should start with zero last activity");
        }
        
        // System should track miners properly across epochs
        for (uint epoch = 1; epoch <= 3; epoch++) {
            for (uint i = 0; i < miners.length; i++) {
                uint256 volume = tao20Core.getEpochMinerVolume(epoch, miners[i]);
                assertEq(volume, 0, "Epoch volume should start at zero");
            }
            
            if (epoch < 3) {
                vm.warp(block.timestamp + 24 * 3600 + 1);
                tao20Core.advanceEpoch();
            }
        }
    }
    
    // ===================== SYSTEM STRESS TESTS =====================
    
    function test_SystemUnderLoad() public {
        // Test system behavior with many operations
        uint256 numOperations = 50;
        
        // Multiple NAV updates
        for (uint i = 0; i < numOperations; i++) {
            vm.warp(block.timestamp + 1800); // 30 minutes
            uint256 nav = tao20Core.updateNAV();
            assertEq(nav, 1e18, "NAV should remain stable in Phase 1");
        }
        
        // Multiple epoch advances
        uint256 startEpoch = 1;
        for (uint i = 0; i < 5; i++) {
            vm.warp(block.timestamp + 24 * 3600 + 1);
            tao20Core.advanceEpoch();
        }
        
        (uint256 finalEpoch,,,, ) = tao20Core.getEpochInfo();
        assertEq(finalEpoch, startEpoch + 5, "Epochs should advance correctly");
    }
    
    function test_SystemStateConsistency() public {
        // Verify system state remains consistent across operations
        
        // Initial state check
        uint256 initialNAV = tao20Core.getCurrentNAV();
        uint256 initialSupply = tao20Token.totalSupply();
        (uint256 initialEpoch,,,, ) = tao20Core.getEpochInfo();
        
        // Perform various operations
        vm.warp(block.timestamp + 3600);
        tao20Core.updateNAV();
        
        vm.warp(block.timestamp + 24 * 3600);
        tao20Core.advanceEpoch();
        
        // Verify state consistency
        assertEq(tao20Core.getCurrentNAV(), initialNAV, "NAV should be consistent in Phase 1");
        assertEq(tao20Token.totalSupply(), initialSupply, "Supply should be unchanged");
        
        (uint256 newEpoch,,,, ) = tao20Core.getEpochInfo();
        assertEq(newEpoch, initialEpoch + 1, "Epoch should have advanced by 1");
    }
    
    // ===================== INTEGRATION WITH PHASE 2 TESTS =====================
    
    function test_Phase2EmissionWeightedOperations() public {
        // Activate Phase 2
        vm.prank(address(stakingManager));
        navCalculator.activateEmissionWeighting();
        
        // Verify Phase 2 behavior
        (bool phase2Active,,) = navCalculator.getPhaseInfo();
        assertTrue(phase2Active, "Should be in Phase 2");
        
        // NAV can now evolve based on emissions
        uint256[] memory navValues = new uint256[](5);
        
        for (uint i = 0; i < 5; i++) {
            vm.warp(block.timestamp + 1800); // 30 minutes
            navValues[i] = tao20Core.updateNAV();
            assertGt(navValues[i], 0, "NAV should be positive in Phase 2");
        }
        
        // Final NAV should reflect emission-weighted calculations
        uint256 finalNAV = tao20Core.getCurrentNAV();
        assertEq(finalNAV, navValues[4], "Final NAV should match last update");
    }
    
    // ===================== COMPREHENSIVE SYSTEM STATE TESTS =====================
    
    function test_SystemStateAfterMultiplePhaseTransitions() public {
        // Start in Phase 1
        assertEq(tao20Core.getCurrentNAV(), 1e18);
        
        // Go to Phase 2
        vm.prank(address(stakingManager));
        navCalculator.activateEmissionWeighting();
        
        vm.warp(block.timestamp + 3600);
        uint256 phase2NAV = tao20Core.updateNAV();
        
        // Back to Phase 1
        vm.prank(address(stakingManager));
        navCalculator.deactivateEmissionWeighting();
        assertEq(tao20Core.getCurrentNAV(), 1e18);
        
        // To Phase 2 again
        vm.prank(address(stakingManager));
        navCalculator.activateEmissionWeighting();
        
        vm.warp(block.timestamp + 3600);
        uint256 phase2NAV2 = tao20Core.updateNAV();
        
        // System should handle transitions gracefully
        assertGt(phase2NAV2, 0, "NAV should be positive after multiple transitions");
    }
    
    function test_CompleteSystemFunctionality() public {
        // This test verifies the entire system works together
        
        // 1. System starts in Phase 1
        assertEq(tao20Core.getCurrentNAV(), 1e18);
        (bool phase2Active,,) = navCalculator.getPhaseInfo();
        assertFalse(phase2Active);
        
        // 2. Advance through some epochs in Phase 1
        for (uint i = 0; i < 3; i++) {
            vm.warp(block.timestamp + 24 * 3600 + 1);
            tao20Core.advanceEpoch();
        }
        
        // 3. Activate Phase 2
        vm.prank(address(stakingManager));
        navCalculator.activateEmissionWeighting();
        
        // 4. Operate in Phase 2 for several epochs
        for (uint i = 0; i < 3; i++) {
            vm.warp(block.timestamp + 1800); // 30 min
            tao20Core.updateNAV();
            
            vm.warp(block.timestamp + 24 * 3600 - 1800 + 1); // Complete the day
            tao20Core.advanceEpoch();
        }
        
        // 5. Verify final state
        (uint256 finalEpoch,,,, ) = tao20Core.getEpochInfo();
        assertEq(finalEpoch, 7, "Should be in epoch 7");
        
        uint256 finalNAV = tao20Core.getCurrentNAV();
        assertGt(finalNAV, 0, "Final NAV should be positive");
        
        (phase2Active,,,) = navCalculator.getPhaseInfo();
        assertTrue(phase2Active, "Should still be in Phase 2");
    }
}
