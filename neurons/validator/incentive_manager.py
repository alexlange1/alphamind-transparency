#!/usr/bin/env python3
"""
TAO20 Incentive Manager
Implements sophisticated reward mechanisms for miners and validators
based on volume generation and performance metrics
"""

import asyncio
import logging
import time
import math
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from collections import defaultdict
from enum import Enum

logger = logging.getLogger(__name__)

class VolumeType(Enum):
    """Types of volume for reward calculation"""
    MINT = "mint"
    REDEEM = "redeem"

@dataclass
class VolumeRecord:
    """Record of volume generated by a miner"""
    miner_ss58: str
    volume_type: VolumeType
    volume_amount: int  # Base units
    creation_id: str
    timestamp: int
    nav_at_time: int  # NAV in base units
    gas_cost: int  # Gas cost in base units

@dataclass
class MinerReward:
    """Reward calculation for a miner"""
    miner_ss58: str
    total_volume: int  # Total volume in base units
    mint_volume: int  # Minting volume in base units
    redeem_volume: int  # Redemption volume in base units
    volume_score: float  # Normalized volume score (0-1)
    tier_multiplier: float  # Tier-based multiplier
    mint_multiplier: float  # 10% bonus for minting
    base_reward: int  # Base reward in base units
    volume_bonus: int  # Volume-based bonus
    mint_bonus: int  # Minting bonus (10% multiplier)
    gas_compensation: int  # Gas cost compensation
    total_reward: int  # Total reward in base units
    rank: int  # Miner rank by volume

@dataclass
class ValidatorReward:
    """Reward calculation for a validator"""
    validator_ss58: str
    attestations_provided: int
    accuracy_score: float  # 0-1 based on NAV accuracy
    stake_amount: int  # Stake in base units
    base_reward: int  # Base reward per attestation
    accuracy_bonus: int  # Accuracy-based bonus
    stake_bonus: int  # Stake-based bonus
    total_reward: int  # Total reward in base units

class IncentiveManager:
    """
    Manages sophisticated reward mechanisms for TAO20 miners and validators
    """
    
    def __init__(
        self,
        total_emissions_per_epoch: int = 1000000000000000000000,  # 1000 TAO in base units
        miner_emissions_share: float = 0.41,  # 41% to miners
        validator_emissions_share: float = 0.41,  # 41% to validators
        mint_multiplier: float = 1.10,  # 10% bonus for minting volume
        gas_compensation_bps: int = 50,  # 0.5% gas compensation
        min_volume_threshold: int = 1000000000000000000,  # 1 TAO minimum for rewards
        tier_thresholds: Optional[List[int]] = None,
        tier_multipliers: Optional[List[float]] = None
    ):
        self.total_emissions_per_epoch = total_emissions_per_epoch
        self.miner_emissions_share = miner_emissions_share
        self.validator_emissions_share = validator_emissions_share
        self.mint_multiplier = mint_multiplier
        self.gas_compensation_bps = gas_compensation_bps
        self.min_volume_threshold = min_volume_threshold
        
        # Tier system for volume-based rewards
        self.tier_thresholds = tier_thresholds or [
            10000000000000000000,   # 10 TAO - Bronze
            50000000000000000000,   # 50 TAO - Silver  
            100000000000000000000,  # 100 TAO - Gold
            500000000000000000000,  # 500 TAO - Platinum
            1000000000000000000000  # 1000 TAO - Diamond
        ]
        self.tier_multipliers = tier_multipliers or [
            1.0,   # Bronze: 1x
            1.2,   # Silver: 1.2x
            1.5,   # Gold: 1.5x
            2.0,   # Platinum: 2x
            3.0    # Diamond: 3x
        ]
        
        # Volume tracking
        self.volume_records: List[VolumeRecord] = []
        self.miner_volumes: Dict[str, Dict[VolumeType, int]] = defaultdict(lambda: defaultdict(int))
        self.epoch_start_time = int(time.time())
        self.epoch_duration = 24 * 60 * 60  # 24 hours
        
        # Validator tracking
        self.validator_attestations: Dict[str, int] = defaultdict(int)
        self.validator_accuracy: Dict[str, List[float]] = defaultdict(list)
        self.validator_stakes: Dict[str, int] = defaultdict(int)  # Store stake amounts
        
        logger.info(f"IncentiveManager initialized with {len(self.tier_thresholds)} tiers")
        logger.info(f"Mint multiplier: {self.mint_multiplier}x")
        logger.info(f"Gas compensation: {self.gas_compensation_bps} bps")
    
    def record_volume(
        self,
        miner_ss58: str,
        volume_type: VolumeType,
        volume_amount: int,
        creation_id: str,
        nav_at_time: int,
        gas_cost: int
    ):
        """Record volume generated by a miner"""
        timestamp = int(time.time())
        
        # Create volume record
        record = VolumeRecord(
            miner_ss58=miner_ss58,
            volume_type=volume_type,
            volume_amount=volume_amount,
            creation_id=creation_id,
            timestamp=timestamp,
            nav_at_time=nav_at_time,
            gas_cost=gas_cost
        )
        
        # Store record
        self.volume_records.append(record)
        
        # Update miner volume tracking
        self.miner_volumes[miner_ss58][volume_type] += volume_amount
        
        logger.info(f"Recorded {volume_type.value} volume: {volume_amount} for miner {miner_ss58}")
    
    def record_validator_attestation(
        self,
        validator_ss58: str,
        accuracy_score: float,
        stake_amount: int
    ):
        """Record validator attestation for reward calculation"""
        self.validator_attestations[validator_ss58] += 1
        self.validator_accuracy[validator_ss58].append(accuracy_score)
        self.validator_stakes[validator_ss58] = stake_amount  # Store the stake amount
        
        # Keep only last 100 accuracy scores
        if len(self.validator_accuracy[validator_ss58]) > 100:
            self.validator_accuracy[validator_ss58] = self.validator_accuracy[validator_ss58][-100:]
        
        logger.debug(f"Recorded attestation for validator {validator_ss58}, accuracy: {accuracy_score}")
    
    def calculate_miner_rewards(self) -> List[MinerReward]:
        """Calculate rewards for all miners based on volume generation"""
        if not self.miner_volumes:
            return []
        
        # Calculate total volume per miner
        miner_totals = {}
        for miner_ss58, volumes in self.miner_volumes.items():
            total_volume = volumes[VolumeType.MINT] + volumes[VolumeType.REDEEM]
            if total_volume >= self.min_volume_threshold:
                miner_totals[miner_ss58] = {
                    'total': total_volume,
                    'mint': volumes[VolumeType.MINT],
                    'redeem': volumes[VolumeType.REDEEM]
                }
        
        if not miner_totals:
            return []
        
        # Sort miners by total volume (descending)
        sorted_miners = sorted(
            miner_totals.items(),
            key=lambda x: x[1]['total'],
            reverse=True
        )
        
        # Calculate total volume across all miners
        total_volume_all = sum(data['total'] for _, data in sorted_miners)
        
        # Calculate rewards
        rewards = []
        total_gas_compensation = 0
        
        for rank, (miner_ss58, data) in enumerate(sorted_miners, 1):
            total_volume = data['total']
            mint_volume = data['mint']
            redeem_volume = data['redeem']
            
            # Calculate volume score (0-1)
            volume_score = total_volume / total_volume_all if total_volume_all > 0 else 0
            
            # Determine tier and multiplier
            tier_multiplier = self._get_tier_multiplier(total_volume)
            
            # Calculate base reward (proportional to volume)
            miner_emissions = self.total_emissions_per_epoch * self.miner_emissions_share
            base_reward = int(miner_emissions * volume_score)
            
            # Calculate volume bonus (additional reward for high volume)
            volume_bonus = int(base_reward * (tier_multiplier - 1.0))
            
            # Calculate minting bonus (10% multiplier for minting volume)
            mint_volume_ratio = mint_volume / total_volume if total_volume > 0 else 0
            mint_bonus = int(base_reward * mint_volume_ratio * (self.mint_multiplier - 1.0))
            
            # Calculate gas compensation
            total_gas_cost = sum(
                record.gas_cost for record in self.volume_records 
                if record.miner_ss58 == miner_ss58
            )
            gas_compensation = int(total_gas_cost * self.gas_compensation_bps / 10000)
            total_gas_compensation += gas_compensation
            
            # Calculate total reward
            total_reward = base_reward + volume_bonus + mint_bonus + gas_compensation
            
            # Create reward object
            reward = MinerReward(
                miner_ss58=miner_ss58,
                total_volume=total_volume,
                mint_volume=mint_volume,
                redeem_volume=redeem_volume,
                volume_score=volume_score,
                tier_multiplier=tier_multiplier,
                mint_multiplier=self.mint_multiplier,
                base_reward=base_reward,
                volume_bonus=volume_bonus,
                mint_bonus=mint_bonus,
                gas_compensation=gas_compensation,
                total_reward=total_reward,
                rank=rank
            )
            
            rewards.append(reward)
        
        # Adjust rewards if gas compensation exceeds budget
        if total_gas_compensation > miner_emissions * 0.1:  # Cap at 10% of miner emissions
            adjustment_factor = (miner_emissions * 0.1) / total_gas_compensation
            for reward in rewards:
                reward.gas_compensation = int(reward.gas_compensation * adjustment_factor)
                reward.total_reward = reward.base_reward + reward.volume_bonus + reward.mint_bonus + reward.gas_compensation
        
        logger.info(f"Calculated rewards for {len(rewards)} miners")
        return rewards
    
    def calculate_validator_rewards(self) -> List[ValidatorReward]:
        """Calculate rewards for all validators based on attestations and accuracy"""
        if not self.validator_attestations:
            return []
        
        # Calculate total attestations
        total_attestations = sum(self.validator_attestations.values())
        if total_attestations == 0:
            return []
        
        # Calculate validator emissions
        validator_emissions = self.total_emissions_per_epoch * self.validator_emissions_share
        
        # Calculate rewards
        rewards = []
        
        for validator_ss58, attestation_count in self.validator_attestations.items():
            # Calculate accuracy score (average of last 100 attestations)
            accuracy_scores = self.validator_accuracy.get(validator_ss58, [])
            accuracy_score = sum(accuracy_scores) / len(accuracy_scores) if accuracy_scores else 0.5
            
            # Use the stored stake amount for this validator
            stake_amount = self.validator_stakes.get(validator_ss58, 1000000000000000000000)
            
            # Calculate base reward (proportional to attestations)
            attestation_share = attestation_count / total_attestations
            base_reward = int(validator_emissions * attestation_share)
            
            # Calculate accuracy bonus
            accuracy_bonus = int(base_reward * accuracy_score * 0.5)  # Up to 50% bonus for accuracy
            
            # Calculate stake bonus (higher stake = higher bonus)
            stake_bonus = int(base_reward * min(stake_amount / 1000000000000000000000, 2.0) * 0.3)  # Up to 60% bonus for stake
            
            # Calculate total reward
            total_reward = base_reward + accuracy_bonus + stake_bonus
            
            # Create reward object
            reward = ValidatorReward(
                validator_ss58=validator_ss58,
                attestations_provided=attestation_count,
                accuracy_score=accuracy_score,
                stake_amount=stake_amount,
                base_reward=base_reward,
                accuracy_bonus=accuracy_bonus,
                stake_bonus=stake_bonus,
                total_reward=total_reward
            )
            
            rewards.append(reward)
        
        logger.info(f"Calculated rewards for {len(rewards)} validators")
        return rewards
    
    def _get_tier_multiplier(self, total_volume: int) -> float:
        """Get tier multiplier based on total volume"""
        for i, threshold in enumerate(self.tier_thresholds):
            if total_volume < threshold:
                return self.tier_multipliers[i]
        
        # If volume exceeds all thresholds, return highest multiplier
        return self.tier_multipliers[-1]
    
    def get_miner_stats(self, miner_ss58: str) -> Dict:
        """Get statistics for a specific miner"""
        volumes = self.miner_volumes.get(miner_ss58, {})
        total_volume = volumes.get(VolumeType.MINT, 0) + volumes.get(VolumeType.REDEEM, 0)
        
        # Calculate tier
        tier_multiplier = self._get_tier_multiplier(total_volume)
        tier_name = self._get_tier_name(tier_multiplier)
        
        # Calculate volume ratios
        mint_ratio = volumes.get(VolumeType.MINT, 0) / total_volume if total_volume > 0 else 0
        redeem_ratio = volumes.get(VolumeType.REDEEM, 0) / total_volume if total_volume > 0 else 0
        
        return {
            'miner_ss58': miner_ss58,
            'total_volume': total_volume,
            'mint_volume': volumes.get(VolumeType.MINT, 0),
            'redeem_volume': volumes.get(VolumeType.REDEEM, 0),
            'mint_ratio': mint_ratio,
            'redeem_ratio': redeem_ratio,
            'tier_name': tier_name,
            'tier_multiplier': tier_multiplier,
            'effective_multiplier': tier_multiplier * (1 + mint_ratio * (self.mint_multiplier - 1))
        }
    
    def _get_tier_name(self, multiplier: float) -> str:
        """Get tier name based on multiplier"""
        tier_names = ['Bronze', 'Silver', 'Gold', 'Platinum', 'Diamond']
        for i, tier_multiplier in enumerate(self.tier_multipliers):
            if abs(multiplier - tier_multiplier) < 0.01:  # Allow for floating point precision
                return tier_names[i]
        return 'Diamond'
    
    def get_leaderboard(self) -> Dict:
        """Get current leaderboard for miners"""
        rewards = self.calculate_miner_rewards()
        
        leaderboard = []
        for reward in rewards[:10]:  # Top 10
            stats = self.get_miner_stats(reward.miner_ss58)
            leaderboard.append({
                'rank': reward.rank,
                'miner_ss58': reward.miner_ss58,
                'total_volume': reward.total_volume,
                'mint_volume': reward.mint_volume,
                'redeem_volume': reward.redeem_volume,
                'tier_name': stats['tier_name'],
                'tier_multiplier': reward.tier_multiplier,
                'effective_multiplier': stats['effective_multiplier'],
                'total_reward': reward.total_reward,
                'volume_score': reward.volume_score
            })
        
        return {
            'leaderboard': leaderboard,
            'total_miners': len(rewards),
            'epoch_start': self.epoch_start_time,
            'epoch_end': self.epoch_start_time + self.epoch_duration
        }
    
    def reset_epoch(self):
        """Reset all tracking for new epoch"""
        self.volume_records.clear()
        self.miner_volumes.clear()
        self.validator_attestations.clear()
        self.validator_accuracy.clear()
        self.validator_stakes.clear()
        self.epoch_start_time = int(time.time())
        
        logger.info("Reset incentive tracking for new epoch")
    
    def get_epoch_progress(self) -> float:
        """Get epoch progress as percentage (0-1)"""
        elapsed = int(time.time()) - self.epoch_start_time
        return min(elapsed / self.epoch_duration, 1.0)
